{"version":3,"sources":["rendering/core/timer.ts","rendering/core/shader.ts","rendering/core/component.ts","rendering/core/shape.ts","rendering/core/shapes/sphere.ts","rendering/core/math.ts","rendering/app/dandelion/dandelionModel.ts","rendering/core/shapes/cylinder.ts","rendering/app/dandelion/program.ts","rendering/core/matrixstack.ts","rendering/app/dandelion/renderer.ts","rendering/Engine.ts","rendering/PureCanvas.tsx","rendering/GraphicsRenderer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Timer","delta","firstTick","Date","now","lastTick","timeNow","this","getDelta","initShaderProgram","gl","vsSource","fsSource","uniforms","vertexShader","loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","program","attribLocations","vertexPosition","getAttribLocation","uniformLocations","R","uniform","getUniformLocation","console","error","getProgramInfoLog","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","newComponent","shape","transform","mat4","create","children","uniformData","createShape","vertices","indices","mode","vao","createVertexArray","bindVertexArray","bindBuffer","ELEMENT_ARRAY_BUFFER","createBuffer","bufferData","Uint32Array","STATIC_DRAW","ARRAY_BUFFER","Float32Array","enableVertexAttribArray","vertexAttribPointer","FLOAT","indexCount","length","createSphereMesh","latitudeBands","longitudeBands","radius","offset","scale","shiftIndices","latNumber","theta","Math","PI","sinTheta","sin","cosTheta","cos","longNumber","phi","sinPhi","cosPhi","x","y","z","push","first","second","sphereToCartesian","createStem","segments","stemShape","vertSegments","height","segmentHeight","i","j","concat","rightDown","rightUp","leftDown","leftUp","TRIANGLES","createCylinder","undefined","createHead","headShape","mesh","createSphere","segmentSeeds","createDandelion","start","stem","head","seed","dotsVertices","dotsIndices","total","v","firstPartDir","secondPartDir","thirdPartDir","seedVertices","headRadius","baseI","seedIndices","dotsShape","POINTS","dotsComponent","LINES","createSeeds","translate","time","log","MatrixStack","size","pointer","stack","copy","mat","mul","DandelionRenderer","engine","defaultProgram","rootComponent","currentProgram","matrixStack","projectionMatrix","cameraMatrix","lightLocation","wind","init","width","clearColor","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","updateSize","setupCamera","bindProgram","updateWind","timer","getTotalTime","perspective","glMatrix","toRadian","draw","clear","COLOR_BUFFER_BIT","drawComponent","component","mulTop","renderShape","child","pop","prepareProgram","prepareUniforms","drawElements","UNSIGNED_INT","transformLocation","modelMatrix","data","uniformMatrix4fv","get","location","uniform1i","useProgram","uniform1f","headRot","Engine","ctx","running","renderer","animate","stop","requestAnimationFrame","tick","PureCanvas","props","ref","node","contextRef","getContext","style","Component","GraphicsRenderer","state","updateDimensions","setState","window","innerWidth","innerHeight","saveContext","addEventListener","removeEventListener","App","className","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3e72965f.chunk.js","sourcesContent":["export class Timer {\n\n  delta = 0;\n  firstTick = Date.now();\n  lastTick = Date.now();\n\n  tick() {\n    const timeNow = Date.now();\n    this.delta = Date.now() - this.lastTick;\n    this.lastTick = timeNow;\n    return this.getDelta();\n  }\n\n  getDelta() {\n    return this.delta;\n  }\n\n  getTotalTime() {\n    return Date.now() - this.firstTick;\n  }\n}\n","import * as R from 'ramda';\nimport { GL } from '../Engine';\n\n\nexport type UniformData = {\n  [name: string]: number\n}\n\nexport type UniformList = {\n  [name: string]: WebGLUniformLocation\n}\n\nexport interface ProgramInfo {\n  program: WebGLProgram,\n  attribLocations: {\n    vertexPosition: number,\n  }\n  uniformLocations: UniformList\n}\n\nexport const initShaderProgram = (\n  gl: GL,\n  vsSource: string,\n  fsSource: string,\n  uniforms: string[]\n): ProgramInfo | null => {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource) as WebGLShader;\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource) as WebGLShader;\n  const shaderProgram = gl.createProgram() as WebGLProgram;\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n    return null;\n  }\n  return {\n    program: shaderProgram,\n    attribLocations: {\n      vertexPosition: gl.getAttribLocation(shaderProgram, 'vertex') as number\n    },\n    uniformLocations: R.reduce(R.merge, {} as any, R.map(\n      uniform => ({[uniform]: gl.getUniformLocation(shaderProgram, uniform)}),\n      uniforms\n    ))\n  } as ProgramInfo;\n}\n\nexport const loadShader = (gl: WebGLRenderingContext, type: number, source: string) => {\n  const shader = gl.createShader(type) as WebGLShader;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\n\nexport const worldProgramUniforms = [\n  'modelViewMatrix',\n  'projectionMatrix'\n]\n\nexport const initWorldProgram = (\n  gl: GL,\n  vsSource: string,\n  fsSource: string,\n  extraUniforms: string[]\n): ProgramInfo | null => initShaderProgram(\n  gl,\n  vsSource,\n  fsSource,\n  R.concat(worldProgramUniforms, extraUniforms)\n)\n","import { Shape } from './shape';\nimport { mat4 } from 'gl-matrix';\nimport { UniformData } from './shader';\n\n\nexport interface Component {\n  shape: Shape | null\n  children: Component[]\n  transform: mat4,\n  uniformData: UniformData\n}\n\nexport const newComponent = (\n  shape: Shape | null = null,\n  transform: mat4 = mat4.create(),\n  children: Component[] = [],\n  uniformData: UniformData = {}\n): Component => ({\n  shape,\n  children,\n  transform,\n  uniformData\n})\n\n","import { GL } from '../Engine';\nimport { ProgramInfo } from './shader';\n\nexport interface Mesh {\n  indices: number[]\n  vertices: number[]\n}\n\nexport interface Shape {\n  mode: number,\n  vao: number,\n  indexCount: number,\n  program: ProgramInfo | null\n}\n\nexport const createQuadShape = (gl: GL) => {\n  const vertices = [\n      -0.6,0.6,0.0,\n      -0.6,-0.6,0.0,\n      0.6,-0.6,0.0,\n      0.6,0.6,0.0\n  ];\n  const indices = [1,2,3,3,1,0];\n  return createShape(gl, vertices, indices, gl.TRIANGLES, null)\n}\n\nexport const createShape = (\n  gl: GL,\n  vertices: number[],\n  indices: number[],\n  mode: number,\n  program: ProgramInfo | null\n): Shape => {\n  const vao = gl.createVertexArray()\n  gl.bindVertexArray(vao)\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n  gl.enableVertexAttribArray(1);\n  gl.vertexAttribPointer(1,3,gl.FLOAT,true,0,0);\n  return {\n    mode,\n    program,\n    indexCount: indices.length,\n    vao: vao as number\n  }\n}\n","import { Shape, createShape, Mesh } from '../shape';\nimport { GL } from '../../Engine';\n\nexport const createSphereMesh = (\n  latitudeBands: number,\n  longitudeBands: number,\n  radius: number,\n  offset: number[] = [0.0, 0.0, 0.0],\n  scale: number[] = [1.0, 1.0, 1.0],\n  shiftIndices: number = 0\n): Mesh => {\n  let vertices = [];\n  let indices = [];\n\n  // Calculate sphere vertex positions, normals, and texture coordinates.\n  for (let latNumber = 0; latNumber <= latitudeBands; ++latNumber) {\n    let theta = latNumber * Math.PI / latitudeBands;\n    let sinTheta = Math.sin(theta);\n    let cosTheta = Math.cos(theta);\n\n    for (let longNumber = 0; longNumber <= longitudeBands; ++longNumber) {\n      let phi = longNumber * 2 * Math.PI / longitudeBands;\n      let sinPhi = Math.sin(phi);\n      let cosPhi = Math.cos(phi);\n\n      let x = cosPhi * sinTheta * scale[0];\n      let y = cosTheta * scale[1];\n      let z = sinPhi * sinTheta * scale[2];\n\n      vertices.push(radius * x + offset[0]);\n      vertices.push(radius * y + offset[1]);\n      vertices.push(radius * z + offset[2]);\n    }\n  }\n\n  // Calculate sphere indices.\n  for (let latNumber = 0; latNumber < latitudeBands; ++latNumber) {\n    for (let longNumber = 0; longNumber < longitudeBands; ++longNumber) {\n      let first = (latNumber * (longitudeBands + 1)) + longNumber + shiftIndices;\n      let second = first + longitudeBands + 1;\n\n      indices.push(first);\n      indices.push(second);\n      indices.push(first + 1);\n\n      indices.push(second);\n      indices.push(second + 1);\n      indices.push(first + 1);\n    }\n  }\n\n  return {\n    vertices: vertices,\n    indices: indices\n  }\n\n}\n\nexport const createSphere = (\n  gl: GL,\n  latitudeBands: number,\n  longitudeBands: number,\n  radius: number,\n  offset: number[] = [0.0, 0.0, 0.0]\n): Shape => {\n  const mesh = createSphereMesh(latitudeBands, longitudeBands, radius, offset)\n  return createShape(\n    gl,\n    mesh.vertices,\n    mesh.indices,\n    gl.TRIANGLES,\n    null\n  )\n}\n","export const normal_random = () => {\n  var u = 0, v = 0;\n  while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n  while(v === 0) v = Math.random();\n  return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n}\n\nexport const randomNormalVector = (): number[] => {\n  const x = normal_random();\n  const y = normal_random();\n  const z = normal_random();\n  const l = Math.sqrt(x*x + y*y + z*z);\n  return [x / l, y / l, z / l];\n}\n\nexport const sphereToCartesian = (phi:  number, theta: number) => {\n  const x = Math.sin(theta) * Math.cos(phi);\n  const y = Math.sin(theta) * Math.sin(phi);\n  const z = Math.cos(theta);\n  return [x,y,z];\n}\n","import { Component, newComponent } from '../../core/component';\nimport { GL } from '../../Engine';\nimport { createShape } from '../../core/shape';\nimport { mat4, glMatrix } from 'gl-matrix';\nimport { createSphere, createSphereMesh } from '../../core/shapes/sphere';\nimport { createCylinder } from '../../core/shapes/cylinder';\nimport { randomNormalVector, sphereToCartesian } from '../../core/math';\n\nexport const STEM_MODE = 1;\nexport const HEAD_MODE = 2;\nexport const SEED_MODE = 3;\nexport const DOT_MODE = 4;\n\nconst stemHeight = 1;\nconst stemRadius = 0.01;\n\nconst createStem = (gl: GL, segments: number): Component => {\n  const stemShape = createCylinder(gl, 10, 9, stemRadius, stemHeight )\n  return newComponent(\n    stemShape,\n    undefined,\n    undefined,\n    {\n      mode: STEM_MODE\n    }\n  );\n}\n\nconst headRadius = 0.05;\nconst createHead = (gl: GL): Component => {\n  const headShape = createSphere(gl, 10, 10, headRadius, [0, 1, 0]);\n  const transform = mat4.create()\n  return newComponent(\n    headShape,\n    transform,\n    undefined,\n    {\n      mode: HEAD_MODE\n    }\n  )\n}\n\nconst segmentSeeds = [1, 3, 5, 7, 10, 13, 10, 7, 5, 3, 1 ]\nconst seedSegmentLength = 0.14;\nconst seedEndLength = 0.08;\nconst createSeeds = (gl: GL): Component => {\n\n  var vertices: number[] = [];\n  var indices: number[] = [];\n\n  var dotsVertices: number[] = [];\n  var dotsIndices: number[] = [];\n\n  var total = 0;\n  for(var i = 0; i < segmentSeeds.length; i++) {\n    for(var j = 0; j < segmentSeeds[i]; j++) {\n      const headRadiusRef = headRadius - 0.01;\n      const theta = (Math.PI / (segmentSeeds.length - 1)) * i;\n      const phi = (2*Math.PI / segmentSeeds[i]) * j;\n      const v = sphereToCartesian(phi, theta);\n      const firstPartDir = sphereToCartesian(phi + 0.7, theta);\n      const secondPartDir = sphereToCartesian(phi - 0.7, theta);\n      const thirdPartDir = sphereToCartesian(phi + 0.35, theta + 0.35);\n\n      const segmentSeedR = headRadius + seedSegmentLength;\n\n      const seedVertices = [\n        v[0] * headRadiusRef, v[1] * headRadiusRef + stemHeight, v[2] * headRadiusRef,\n        v[0] * segmentSeedR, v[1] * segmentSeedR + stemHeight, v[2] * segmentSeedR,\n\n        v[0] * segmentSeedR + firstPartDir[0] * seedEndLength,\n        v[1] * segmentSeedR + firstPartDir[1] * seedEndLength + stemHeight,\n        v[2] * segmentSeedR + firstPartDir[2] * seedEndLength,\n\n        v[0] * segmentSeedR + secondPartDir[0] * seedEndLength,\n        v[1] * segmentSeedR + secondPartDir[1] * seedEndLength + stemHeight,\n        v[2] * segmentSeedR + secondPartDir[2] * seedEndLength,\n\n        v[0] * segmentSeedR + thirdPartDir[0] * seedEndLength,\n        v[1] * segmentSeedR + thirdPartDir[1] * seedEndLength + stemHeight,\n        v[2] * segmentSeedR + thirdPartDir[2] * seedEndLength,\n      ]\n\n      const baseI = total * 5;\n      const seedIndices = [\n        baseI, baseI + 1,\n        baseI + 1, baseI + 2,\n        baseI + 1, baseI + 3,\n        baseI + 1, baseI + 4,\n      ]\n\n      vertices = vertices.concat(seedVertices);\n      indices = indices.concat(seedIndices);\n\n      dotsVertices = dotsVertices.concat([\n        v[0] * segmentSeedR + firstPartDir[0] * seedEndLength,\n        v[1] * segmentSeedR + firstPartDir[1] * seedEndLength + stemHeight,\n        v[2] * segmentSeedR + firstPartDir[2] * seedEndLength,\n\n        v[0] * segmentSeedR + secondPartDir[0] * seedEndLength,\n        v[1] * segmentSeedR + secondPartDir[1] * seedEndLength + stemHeight,\n        v[2] * segmentSeedR + secondPartDir[2] * seedEndLength,\n\n        v[0] * segmentSeedR + thirdPartDir[0] * seedEndLength,\n        v[1] * segmentSeedR + thirdPartDir[1] * seedEndLength + stemHeight,\n        v[2] * segmentSeedR + thirdPartDir[2] * seedEndLength,\n      ])\n\n\n      dotsIndices = dotsIndices.concat([\n        total * 3, total * 3 + 1, total * 3 + 2\n      ])\n\n      total++;\n    }\n  }\n\n  const dotsShape = createShape(\n    gl,\n    dotsVertices,\n    dotsIndices,\n    gl.POINTS,\n    null\n  )\n\n  const dotsComponent = newComponent(\n    dotsShape,\n    undefined,\n    undefined,\n    {\n      mode: DOT_MODE\n    }\n  )\n\n  const shape = createShape(\n    gl,\n    vertices,\n    indices,\n    gl.LINES,\n    null\n  )\n\n  const transform = mat4.create();\n  return newComponent(\n    shape,\n    transform,\n    [dotsComponent],\n    {\n      mode: SEED_MODE\n    }\n  )\n}\n\nexport const createDandelion = (gl: GL): Component => {\n  const start = Date.now();\n  const stem = createStem(gl, 10)\n  const head = createHead(gl)\n  const seed = createSeeds(gl)\n  const transform = mat4.create()\n  mat4.translate(transform, transform, [0, -0.7, -0.5])\n  mat4.scale(transform, transform, [1.4, 1.4, 1.4])\n  const time = Date.now() - start;\n  console.log(\"Generating dandelion took: \" + time + \"ms.\")\n  return newComponent(\n    undefined,\n    transform,\n    [stem, head, seed]\n  )\n}\n","import { Shape, createShape } from '../shape';\nimport { GL } from '../../Engine';\n\nexport const createCylinder = (\n  gl: GL,\n  segments: number,\n  vertSegments: number,\n  radius: number,\n  height: number\n): Shape => {\n  const segmentHeight = height / segments;\n  var vertices: number[] = [];\n  var indices: number[] = [];\n  for(var i=0; i <= segments; i++) {\n    for(var j = 0; j < vertSegments; j++) {\n      const phi = ((Math.PI * 2) / vertSegments) * j;\n      vertices = vertices.concat([\n        Math.cos(phi) * radius, i * segmentHeight, Math.sin(phi) * radius\n      ]);\n\n      if(i != segments) {\n        const rightDown = vertSegments * i + j;\n        const rightUp = (vertSegments * (i + 1)) + j;\n        const leftDown = (j == vertSegments - 1) ? vertSegments * i : vertSegments * i + j + 1;\n        const leftUp = (j == vertSegments - 1) ?  vertSegments * (i + 1) : vertSegments * (i + 1) + j + 1;\n        indices = indices.concat([\n          leftDown, rightUp, rightDown,\n          leftUp, rightUp, leftDown\n        ])\n      }\n    }\n  }\n  return createShape(\n    gl,\n    vertices,\n    indices,\n    gl.TRIANGLES,\n    null\n  );\n}\n","import {HEAD_MODE, STEM_MODE, SEED_MODE, DOT_MODE} from './dandelionModel'\n\nexport const uniforms: string[] = [\n  'modelMatrix', 'cameraMatrix', 'projectionMatrix', 'lightLocation', 'mode', 'headRot'\n];\n\nexport const vsSource = `#version 300 es\n  #define M_PI 3.1415926535897932384626433832795\n  uniform mat4 projectionMatrix;\n  uniform mat4 cameraMatrix;\n  uniform mat4 modelMatrix;\n  uniform float headRot;\n  uniform int mode;\n  layout(location = 1) in vec3 vertex;\n  layout(location = 2) in vec3 previousVertex;\n  out highp vec3 vertexPos;\n  flat out int imode;\n\n  vec4 moveStem(vec4 v) {\n    float h = vertex.y;\n    vec4 moved = vec4(0.0, 0.0, 0.0, 1.0);\n    moved.z = v.z;\n    moved.x = cos(headRot) * v.x - sin(headRot) * v.y;\n    moved.y = sin(headRot) * v.x + cos(headRot) * v.y;\n    vec4 interpolated = (1.0-pow(h,1.2)) * v + (pow(h,1.2)) * moved;\n    return interpolated;\n  }\n\n  vec4 moveHead(vec4 v) {\n    vec4 moved = vec4(0.0, 0.0, 0.0, 1.0);\n    moved.z = v.z;\n    moved.x = cos(headRot) * v.x - sin(headRot) * v.y;\n    moved.y = sin(headRot) * v.x + cos(headRot) * v.y;\n    return moved;\n  }\n\n  void main() {\n    imode = mode;\n    highp vec4 v4Pos = vec4(vertex, 1.0);\n    highp vec4 transVertex = v4Pos;\n    if(mode == ${STEM_MODE}) {\n      transVertex = moveStem(transVertex);\n    } else {\n      transVertex = moveHead(transVertex);\n    }\n    if(mode == ${DOT_MODE}) {\n      gl_PointSize = 7.0;\n    }\n    transVertex = modelMatrix * transVertex;\n    vertexPos = transVertex.xyz / transVertex.w;\n    gl_Position = projectionMatrix * cameraMatrix * transVertex;\n  }\n`\n\nexport const fsSource = `#version 300 es\n  uniform mediump vec3 lightLocation;\n  in highp vec3 vertexPos;\n  flat in int imode;\n  out highp vec4 outColor;\n\n  void main() {\n    if(imode == ${DOT_MODE}) {\n      mediump vec2 coord = gl_PointCoord.xy - vec2(0.5, 0.5);\n      if(coord.x * coord.x + coord.y * coord.y > 0.25) discard;\n    }\n    mediump vec3 color = vec3(0.0, 0.0, 0.0);\n    mediump float ambient = 0.3;\n    mediump vec3 lightDir = normalize(lightLocation - vertexPos);\n    outColor = vec4(0.0, 0.0, 0.0, 1.0);\n  }\n`\n","import { mat4 } from 'gl-matrix';\n\nexport class MatrixStack {\n  pointer = 0\n  stack: mat4[] = []\n  constructor(private size: number) {\n    for(var i = 0; i < size; i++) {\n      this.stack.push(mat4.create())\n    }\n  }\n\n  push() {\n    if(this.pointer == this.size - 1) {\n      throw \"MatrixStack out of bounds\"\n    }\n    this.pointer++;\n    mat4.copy(this.stack[this.pointer], this.stack[this.pointer - 1])\n  }\n\n  pop() {\n    this.pointer--;\n  }\n\n  mulTop(mat: mat4) {\n    mat4.mul(this.stack[this.pointer], this.stack[this.pointer], mat)\n  }\n\n  get() {\n    return this.stack[this.pointer]\n  }\n}\n","import { GL, Engine } from '../../Engine';\nimport { createQuadShape, Shape } from '../../core/shape';\nimport { initShaderProgram, ProgramInfo } from '../../core/shader';\nimport { vsSource, fsSource, uniforms } from '../../app/dandelion/program'\nimport { Component, newComponent } from '../../core/component';\nimport { createDandelion } from '../../app/dandelion/dandelionModel';\nimport { MatrixStack } from '../../core/matrixstack';\nimport { mat4, glMatrix } from 'gl-matrix';\nimport { Timer } from '../../core/timer';\n\nexport class DandelionRenderer {\n  constructor(\n    private gl: GL,\n    private engine: Engine\n  ) {\n\n  }\n\n  defaultProgram: ProgramInfo | null = null\n  rootComponent: Component | null = null\n  currentProgram: ProgramInfo | null = null\n  matrixStack: MatrixStack = new MatrixStack(16)\n  projectionMatrix: mat4 = mat4.create();\n  cameraMatrix: mat4 = mat4.create();\n  lightLocation: number[] = [5, 5, 0];\n  wind: number = -0.13;\n\n  init = (width: number, height: number) => {\n    const gl = this.gl\n    gl.clearColor(1.0, 1.0, 1.0, 1.0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)\n    this.defaultProgram = initShaderProgram(gl, vsSource, fsSource, uniforms);\n    this.rootComponent = newComponent(\n      null,\n      undefined,\n      [createDandelion(gl)]\n    )\n    this.updateSize(width, height);\n    this.setupCamera();\n    this.bindProgram(this.defaultProgram as ProgramInfo)\n  }\n\n  updateWind = () => {\n    const x = this.engine.timer.getTotalTime() / 1000.0;\n    this.wind = -(Math.sin(Math.cos(x + 0.5  + 2 * Math.sin(2 * x) + 2*Math.cos(0.5 * x))) + 1) / 14\n  }\n\n  updateSize = (width: number, height: number) => {\n    mat4.perspective(\n      this.projectionMatrix,\n      glMatrix.toRadian(90),\n      width / height,\n      0.1,\n      100\n    )\n  }\n\n  setupCamera = () => {\n    mat4.translate(\n      this.cameraMatrix,\n      this.cameraMatrix,\n      [0.0, -0.3, -1]\n    )\n  }\n\n  draw = (delta: number) => {\n    const gl = this.gl;\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    //mat4.rotate(this.rootComponent?.transform as mat4, this.rootComponent?.transform as mat4, 0.0003 * delta, [0, 1, 0])\n    this.drawComponent(this.rootComponent as Component)\n    this.updateWind();\n  };\n\n  drawComponent = (component: Component) => {\n    const shape = component.shape\n    this.matrixStack.push();\n    this.matrixStack.mulTop(component.transform);\n    if(shape != null) this.renderShape(component)\n    for(const child of component.children) {\n      this.drawComponent(child);\n    }\n    this.matrixStack.pop();\n    this.bindProgram(null);\n  }\n\n  renderShape = (component: Component) => {\n    const gl = this.gl;\n    const shape = component.shape as Shape\n    this.prepareProgram(shape)\n    this.prepareUniforms(component)\n    gl.bindVertexArray(shape?.vao as number);\n    gl.drawElements(shape.mode, shape.indexCount, gl.UNSIGNED_INT, 0)\n  }\n\n  prepareUniforms = (component: Component) => {\n    const gl = this.gl\n    const transformLocation = this.currentProgram?.uniformLocations.modelMatrix as number\n    gl.uniformMatrix4fv(transformLocation, false, this.matrixStack.get())\n    for(const data in component.uniformData) {\n      const location = this.currentProgram?.uniformLocations[data] as WebGLUniformLocation\n      gl.uniform1i(location, component.uniformData[data])\n    }\n  }\n\n  prepareProgram = (shape: Shape) => {\n    if(shape.program == null) {\n      this.bindProgram(this.defaultProgram as ProgramInfo)\n    } else {\n      this.bindProgram(shape.program)\n    }\n  }\n\n  bindProgram = (program: ProgramInfo | null) => {\n    const gl = this.gl;\n    if(program == null) {\n      this.currentProgram = null;\n      gl.useProgram(null);\n      return;\n    }\n    if(this.currentProgram === program) return;\n    gl.useProgram(program.program);\n    gl.uniformMatrix4fv(program.uniformLocations.projectionMatrix, false, this.projectionMatrix);\n    gl.uniformMatrix4fv(program.uniformLocations.cameraMatrix, false, this.cameraMatrix);\n    gl.uniform1f(program.uniformLocations.headRot, this.wind);\n    this.currentProgram = program;\n  }\n}\n","import { createQuadShape, Shape } from './core/shape';\nimport { initShaderProgram, ProgramInfo } from './core/shader';\nimport { vsSource, fsSource, uniforms } from './app/dandelion/program'\nimport { Component, newComponent } from './core/component';\nimport { createDandelion } from './app/dandelion/dandelionModel';\nimport { MatrixStack } from './core/matrixstack';\nimport { mat4, glMatrix } from 'gl-matrix';\nimport { Timer } from './core/timer';\nimport { DandelionRenderer } from './app/dandelion/renderer';\nimport { head } from 'ramda';\n\nexport type GL = WebGL2RenderingContext\n\nexport interface Renderer {\n  init: (width: number, height: number) => void;\n  draw: (delta: number) => void;\n  updateSize: (width: number, height: number) => void;\n}\n\nexport class Engine {\n\n  gl: GL;\n  running: boolean = false;\n  timer: Timer = new Timer();\n  renderer: Renderer\n\n  constructor(ctx: GL, width: number, height: number) {\n    this.gl = ctx;\n    this.renderer = new DandelionRenderer(ctx, this)\n    this.init(width, height)\n  }\n\n  start = () => {\n    this.running = true;\n    this.animate();\n  }\n\n  stop = () => {\n    this.running = false;\n  }\n\n  animate = () => {\n    this.draw();\n    if(this.running) requestAnimationFrame(this.animate);\n  }\n\n\n  init = (width: number, height: number) => {\n    this.renderer.init(width, height);\n  }\n\n\n  draw = () => {\n    const delta = this.timer.tick();\n    this.renderer.draw(delta);\n  };\n\n  updateSize = (width: number, height: number) => {\n    this.renderer.updateSize(width, height);\n  }\n}\n","import React, { Component } from 'react';\n\nexport interface PureCanvasProps {\n  contextRef: Function;\n  width: number;\n  height: number;\n}\n\nexport class PureCanvas extends Component<PureCanvasProps, any> {\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  render() {\n    return (\n      <canvas\n        width={this.props.width * 2}\n        height={this.props.height * 2}\n        ref={node =>\n          node ? this.props.contextRef(node.getContext('webgl2')) : null\n        }\n        style={{width: this.props.width, height: this.props.height}}\n      />\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { Engine } from './Engine';\nimport { PureCanvas } from './PureCanvas';\n\ninterface GraphicsRendererState {\n  engine: Engine | null;\n  width: number;\n  height: number;\n}\n\nexport class GraphicsRenderer extends Component<any, GraphicsRendererState> {\n  state: GraphicsRendererState = {\n    engine: null,\n    width: 0,\n    height: 0\n  };\n\n  componentDidMount() {\n    window.addEventListener('resize', this.updateDimensions);\n    this.updateDimensions();\n  }\n\n  componentWillUnmount() {\n    this.state.engine?.stop();\n    window.removeEventListener('resize', this.updateDimensions);\n  }\n\n  updateDimensions = () => {\n    console.log('update!')\n    this.setState({ width: window.innerWidth, height: window.innerHeight });\n    this.state.engine?.updateSize(window.innerWidth, window.innerHeight)\n  };\n\n  saveContext = (ctx: WebGL2RenderingContext) => {\n    this.setState({\n      engine: new Engine(ctx, window.innerWidth, window.innerHeight),\n    });\n  };\n\n  render() {\n    this.state.engine?.start();\n    return <PureCanvas width={window.innerWidth} height={window.innerHeight} contextRef={this.saveContext} />;\n  }\n\n}\n","import React from 'react';\nimport './App.css';\nimport { GraphicsRenderer } from './rendering/GraphicsRenderer'\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <div className=\"desc\">\n        <h1></h1>\n      </div>\n      <GraphicsRenderer> </GraphicsRenderer>\n\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}